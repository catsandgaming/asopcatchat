<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Cafe Autonomous Chat Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // Enable dark mode based on 'dark' class on the body
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        // Custom colors based on the Cafe Cat theme
                        'cat-purple': '#8B5CF6',
                        'cat-pink': '#EC4899',
                        'cat-owner': '#34D399', // Emerald for the Owner
                        'cat-background': '#f7f7f7',
                        'cat-text': '#1f2937',
                        'cat-cream': '#fef3c7',
                        'cat-red': '#EF4444',
                        'cat-blue': '#3B82F6' 
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        /* Define color variables for easy theme switching */
        :root {
            --color-bg-main: var(--tw-colors-cat-background);
            --color-text-main: var(--tw-colors-cat-text);
            --color-bubble-bg: #ffffff;
            --color-bubble-border: #e5e7eb;
            --color-input-bg: #ffffff;
        }

        .dark {
            --color-bg-main: #111827; /* Dark Slate */
            --color-text-main: #f3f4f6; /* Light Text */
            --color-bubble-bg: #1f2937; /* Dark bubble */
            --color-bubble-border: #4b5563; /* Dark border */
            --color-input-bg: #1f2937; 
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg-main);
            color: var(--color-text-main);
            min-height: 100vh;
            transition: background-color 0.5s ease;
        }
        .chat-container-main {
            flex-grow: 1;
            padding: 1rem 0;
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px); /* Adjusted height */
        }
        .chat-window {
            flex-grow: 1;
            overflow-y: auto;
            padding: 0 1rem;
            scroll-behavior: smooth;
        }
        .chat-bubble {
            border-radius: 1rem;
            padding: 0.75rem 1.25rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            background-color: var(--color-bubble-bg);
            border: 1px solid var(--color-bubble-border);
            transition: background-color 0.5s ease, border-color 0.5s ease;
        }
        /* Custom formatting for cat/owner names in dialogue */
        .cat-name {
            font-weight: 800; /* Extra bold */
            color: var(--tw-colors-cat-purple);
        }
        .owner-name {
            font-weight: 800;
            color: var(--tw-colors-cat-owner); /* Green for Owner */
        }
        .input-area {
            position: sticky;
            bottom: 0;
            background-color: var(--color-input-bg);
            padding: 1rem;
            border-top: 1px solid var(--color-bubble-border);
            box-shadow: 0 -4px 6px -1px rgb(0 0 0 / 0.1);
            transition: background-color 0.5s ease, border-top 0.5s ease;
        }
        .dark .chat-bubble {
            color: var(--color-text-main);
        }
        .dark .text-gray-700 { color: #d1d5db !important; }
        .dark .text-gray-500 { color: #9ca3af !important; }

        /* Style the input field to adapt to dark mode */
        #initial-prompt {
            background-color: var(--color-input-bg);
            color: var(--color-text-main);
            border-color: var(--color-bubble-border);
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Header (Always Visible) -->
    <header class="bg-cat-purple shadow-xl p-4 md:p-6 sticky top-0 z-10">
        <div class="max-w-4xl mx-auto flex justify-between items-center">
             <!-- Title and Logo -->
            <h1 class="text-xl md:text-3xl font-extrabold text-white flex items-center">
                <span class="inline-block mr-2 text-2xl md:text-4xl">üêà</span> Cat Chat Simulator
            </h1>
            
            <!-- Theme Toggle Button -->
            <button id="theme-toggle" onclick="toggleTheme()" title="Toggle Dark/Light Mode" class="p-2 rounded-full text-white hover:bg-cat-pink/50 transition">
                <!-- Sun Icon (Light Mode) -->
                <svg id="sun-icon" class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16.5 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z" />
                </svg>
                <!-- Moon Icon (Dark Mode) - Hidden by default, shown via JS/CSS -->
                <svg id="moon-icon" class="h-6 w-6 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M21.75 2.25v1.5a.75.75 0 01-1.5 0V2.25a.75.75 0 011.5 0zM12 21.75a.75.75 0 01-.75-.75h1.5a.75.75 0 01-.75.75zM4.5 9.75a.75.75 0 01-.75-.75h1.5a.75.75 0 01-.75.75zM19.5 9.75a.75.75 0 01-.75-.75h1.5a.75.75 0 01-.75.75zM6 12a6 6 0 1112 0 6 6 0 01-12 0z" />
                </svg>
            </button>
        </div>
        <p class="text-sm text-cat-cream text-center mt-1">Define your cat's personalities in the code below and watch the drama unfold!</p>
        <p id="status-display" class="text-xs text-cat-cream text-center mt-1 font-mono">Status: Initializing...</p>
    </header>

    <!-- Main Chat Window (Always Visible) -->
    <main class="chat-container-main">
        <div id="chat-window" class="chat-window space-y-4">
            <!-- Messages will be injected here -->
            <div id="initial-message" class="flex justify-center my-8">
                <div class="text-center chat-bubble bg-white border border-cat-purple/30 max-w-sm">
                    <p class="font-semibold text-gray-700 mb-2">Simulation Ready</p>
                    <p class="text-sm text-gray-500">Enter a topic and click 'Start Chat'.</p>
                </div>
            </div>
            <div id="loading-spinner" class="hidden flex justify-center py-8">
                <svg class="animate-spin h-8 w-8 text-cat-purple" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        </div>
    </main>

    <!-- Input/Control Area (Always Visible) -->
    <div class="input-area">
        <div class="max-w-4xl mx-auto flex flex-col space-y-3">
            <input 
                type="text" 
                id="initial-prompt" 
                placeholder="Enter the initial scene/topic here (e.g., A customer just ordered a tuna sandwich)."
                class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cat-purple">
            
            <button id="start-button" onclick="startChat()"
                    class="w-full bg-cat-purple hover:bg-cat-pink text-white font-semibold py-3 px-5 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed text-lg">
                Start Chat
            </button>
        </div>
    </div>


    <!-- JavaScript Logic (Core Simulation) -->
    <script type="module">

        // --- Configuration ---
        // NOTE: The API Key is intentionally left as an empty string to be provided by the execution environment.
        const API_KEY = ""; 
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
        const AUTO_INTERVAL_MS = 3000; // 3 seconds between turns

        
        // ==============================================================================
        //  CAT ROSTER
        // ==============================================================================

        const CAT_ROSTER = [
            // Your wonderful cats are here!
            { 
                name: "Ronnie", 
                breed: "Ragdoll", 
                personality: "A big mama's boy, also nicknamed 'Ronster' and 'Floof ball'. His favorite spot is the hammock or the pram, and he loves his laser toy.", 
                likes: "Being centre of attention, sitting in bags, straws", 
                dislikes: "Being away from his mom" 
            },
            { 
                name: "Jigsaw", 
                breed: "Calico Moggy", 
                personality: "Jiggy is moody but secretly a lovable lap cat. Her favorite spot is on the jigsaw board. She is sister to Marble and Banjo.", 
                likes: "Treats (treats and more treats!)", 
                dislikes: "Being petted near her face" 
            },
            { 
                name: "Bear", 
                breed: "British Shorthair Colourpoint", 
                personality: "Big bear, or 'Bearilicious', is extremely sleepy and lazy. He loves his bed, the cream sofa, and the hidey box. He is Button's brother.", 
                likes: "Snoozing, treats, cuddles", 
                dislikes: "Being awake" 
            },
            { 
                name: "Jet", 
                breed: "Moggie", 
                personality: "Jetticus is playful and chilled, often found on the chair in the window or the pram. His favorite toys are the Worm and the laser pointer.", 
                likes: "Playing with his worm, marshmallows", 
                dislikes: "Being picked up" 
            },
            { 
                name: "Shadow", 
                breed: "Moggie", 
                personality: "A sweet and friendly cat. His favorite spot is in the cat tree hammocks, and his favorite toy is the real mouse fur toy. He is brother to Dash and Thor.", 
                likes: "Pets and cuddles", 
                dislikes: "Loud noises" 
            },
            { 
                name: "Thor", 
                breed: "Maine Coon + Norwegian Forest + Moggie", 
                personality: "Nicknamed 'Theodorus Explorus', he is the biggest softie. He loves being in the cat trees. He is brother to Dash and Shadow.", 
                likes: "Being petted and purring", 
                dislikes: "Having no cuddles" 
            },
            { 
                name: "Marble", 
                breed: "Tortoiseshell Moggie", 
                personality: "Marbie Barbie or Marbs is very loving and affectionate. She loves cuddling in a cat tree and playing with the green fish on a stick. She is sister to Banjo and Jigsaw.", 
                likes: "Being fussed", 
                dislikes: "The cat box" 
            },
            { 
                name: "Banjo", 
                breed: "Tortoiseshell Moggie", 
                personality: "Banj is loving and affectionate. She loves being in the cat tree and playing with the green fish toy. She is sister to Marble and Jigsaw.", 
                likes: "Being fussed, cuddles", 
                dislikes: "Being apart from her sisters" 
            },
            { 
                name: "Button", 
                breed: "British Shorthair Colourpoint", 
                personality: "A sweet and sleepy cat who loves snoozing with her friends in the hammock. Her favorite toys are bags or tape. She is Bear's sister.", 
                likes: "Snoozing with her friends", 
                dislikes: "Being picked up" 
            },
            { 
                name: "Dash", 
                breed: "Moggie", 
                personality: "Dashy Dashy Doo Da is friendly and playful. She loves being nosy and hanging out in the tiny cat hammock. She is sister to Thor and Shadow.", 
                likes: "Being nosy, pets when she's snoozing", 
                dislikes: "Being picked up for home time" 
            }
        ];

        const OWNER_PROFILE = { 
            name: "Owner", 
            breed: "Human", 
            personality: "Caring, busy, focused on cafe operations. They are sometimes worried about the cat's drama.", 
            likes: ["Happy cats", "Coffee"], 
            dislikes: ["Vet visits", "Knocked-over food displays"] 
        };
        
        // Setup characters for strict turn order: Owner (0), Ronnie (1), Jigsaw (2), etc.
        const ORDERED_CATS = [...CAT_ROSTER];
        let characters = [OWNER_PROFILE, ...ORDERED_CATS]; 

        // --- Global State Variables ---
        let chatHistory = [];
        let isSending = false;
        let chatStarted = false;
        let intervalId = null; // Used for auto-progression

        // --- UI Element Access ---
        const chatWindow = document.getElementById('chat-window');
        const initialPromptInput = document.getElementById('initial-prompt');
        const startButton = document.getElementById('start-button');
        const loadingSpinner = document.getElementById('loading-spinner');
        const initialMessage = document.getElementById('initial-message');
        const statusDisplay = document.getElementById('status-display');
        const body = document.body;
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');
        
        // --- Utility Functions ---
        
        function updateStatusDisplay() {
            const status = intervalId ? 'Running Automatically' : 'Ready';
            statusDisplay.textContent = `Status: ${status} | Roster: ${CAT_ROSTER.length} cats (plus Owner).`;
        }
        
        // --- Theme Toggle Logic ---
        window.toggleTheme = function() {
            const isDarkMode = body.classList.toggle('dark');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            
            sunIcon.classList.toggle('hidden', isDarkMode);
            moonIcon.classList.toggle('hidden', !isDarkMode);
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            // Check if the user prefers dark mode (only if no theme is saved)
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches; 

            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                body.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                // Default to light mode
                body.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
        }
        
        function buildSystemInstruction(topic, history, nextSpeakerName) {
            let instruction = "You are the autonomous script generator for a Cat Cafe Simulation. The characters are a group of cats and their Owner. ";
            instruction += "Your task is to generate the **next turn of the conversation** among these characters based on the topic and the current dialogue history. ";
            instruction += "The conversation should be dynamic, realistic, and reflect each character's established personality. ";
            instruction += "The Owner is a mandatory participant but will speak only on their designated turn.\n\n";
            instruction += "--- RULES ---\n";
            instruction += "1. The current topic is: " + topic + "\n";
            instruction += "2. Format the entire response as a single block of dialogue using the format 'CharacterName: [Dialogue]'. Use newline characters for multiple speakers in one turn.\n";
            instruction += "3. The dialogue must progress with each turn. The conversation should only stop if explicitly told to, or if the auto-progression is stopped by the user.\n";
            instruction += "4. Do NOT include any introductory or concluding text. Just output the raw dialogue.\n";
            instruction += "5. **STRICT TURN-TAKING:** Only the character named '" + nextSpeakerName + "' is allowed to speak or take an action in this turn. Do not generate dialogue for any other character.\n";
            instruction += "6. **CLEAN FORMATTING:** The dialogue generated must be spoken text only. Do not include action descriptions, tone hints, or mood indicators inside parentheses (), square brackets [], or use markdown formatting symbols like asterisks (*) or hash marks (#). The output must strictly be in the format 'CharacterName: Spoken dialogue.', with only standard punctuation (periods, commas, exclamation marks, question marks, and quotation marks).\n";
            instruction += "--- CHARACTER PROFILES (Current Roster) ---\n";

            characters.forEach(char => {
                const likes = char.likes || "Unknown";
                const dislikes = char.dislikes && char.dislikes.length > 0 ? ` (Dislikes: ${char.dislikes})` : '';
                instruction += `- ${char.name} (${char.breed}): ${char.personality}. Likes: ${likes}.${dislikes}\n`;
            });
            
            if (history.length === 0) { 
                instruction += "\nBegin the simulation by having the characters immediately reacting to the initial topic/scene.";
            } else {
                instruction += "\nGenerate the next turn of dialogue by having the designated speaker respond to the previous statement and move the discussion forward.";
            }

            return instruction;
        }

        function renderMessage(text) {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = 'flex justify-start w-full';
            
            const messageBubble = document.createElement('div');
            const isError = text.includes("The simulation hit a wall") || text.includes("Error:");
            
            // Adjust class list dynamically for dark/light mode
            messageBubble.className = `max-w-4xl chat-bubble mt-2 shadow-md whitespace-pre-wrap ${isError ? 'bg-red-100 dark:bg-red-900 border-red-400' : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700'}`;
            
            // Highlight speaker names (Owner is the only one in the 'owner-name' class)
            const charNames = characters.map(c => c.name).join('|');
            const dialogueRegex = new RegExp(`(^|\\n)(${charNames}): (.*)`, 'g');
            
            const formattedText = text.replace(dialogueRegex, (match, p1, name, dialogue) => {
                const nameClass = name === 'Owner' ? 'owner-name' : 'cat-name';
                return `${p1}<span class="${nameClass}">${name}:</span> ${dialogue}`;
            });

            messageBubble.innerHTML = formattedText;
            messageWrapper.appendChild(messageBubble);
            chatWindow.appendChild(messageWrapper);
            chatWindow.scrollTop = chatWindow.scrollHeight; 
        }

        // --- Network and Retry Logic ---

        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    // Specific handling for common API errors
                    if (response.status === 403) throw new Error(`API returned status 403: Forbidden - Check API Key configuration.`);
                    if (response.status !== 429) throw new Error(`API returned status ${response.status}: ${response.statusText || await response.text()}`);
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    // Do not log retries as errors
                }
                // Exponential backoff
                await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000));
            }
            throw new Error("API call failed after multiple retries due to persistent network errors or rate limiting.");
        }

        // --- Chat Control ---

        window.stopChat = function() {
            if (intervalId !== null) {
                clearInterval(intervalId);
                intervalId = null;
                startButton.textContent = "Start Chat";
                startButton.onclick = window.startChat;
                updateStatusDisplay();
                
                renderMessage("SYSTEM: Automatic progression stopped by user. Click 'Start Chat' to resume.");
            }
        }

        window.startChat = function() {
            if (isSending) return;

            const topic = initialPromptInput.value.trim();
            if (!topic) {
                renderMessage("SYSTEM: Please enter a topic before starting the chat.");
                return;
            }

            initialMessage.classList.add('hidden');
            
            if (!chatStarted) {
                // Initialize for the first turn
                chatHistory = [];
                chatStarted = true;

                // Render the topic message
                renderMessage(`Topic: ${topic}\n\nStrict sequential turn order established.`);
            }

            // Change button text and function
            startButton.textContent = "Stop Chat";
            startButton.onclick = window.stopChat;
            updateStatusDisplay();

            // Start the auto-progression
            intervalId = setInterval(window.generateNextTurn, AUTO_INTERVAL_MS);

            // Generate the first turn immediately without waiting for the interval
            window.generateNextTurn();
        }

        window.generateNextTurn = async function() {
            if (isSending) return;

            const topic = initialPromptInput.value.trim();
            if (!topic) {
                window.stopChat();
                renderMessage("SYSTEM: The chat automatically stopped because the topic field was cleared.");
                return;
            }
            
            isSending = true;
            startButton.disabled = true;
            // loadingSpinner.classList.remove('hidden'); // Only show loading for the first turn to avoid flicker

            // --- LOGIC FOR DETERMINING NEXT SPEAKER ---
            const totalCharacters = characters.length;
            const turnCount = chatHistory.filter(msg => msg.role === 'model').length; // Count only model responses
            const nextSpeakerIndex = turnCount % totalCharacters;
            const nextSpeaker = characters[nextSpeakerIndex];
            const nextSpeakerName = nextSpeaker.name;
            // ----------------------------------------

            const systemPrompt = buildSystemInstruction(topic, chatHistory, nextSpeakerName);

            const actionQuery = "It is now " + nextSpeakerName + "'s turn. Generate only their single line of spoken dialogue or action, making sure the output contains NO extra symbols (like *, [, (, or #)."

            // Add the current action query to history for context
            const currentHistory = [...chatHistory, { role: "user", parts: [{ text: actionQuery }] }];
            
            const payload = {
                contents: currentHistory,
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };
            
            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetchWithRetry(GEMINI_API_URL, options);
                
                const result = await response.json();
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (text && text.trim().length > 0) {
                    renderMessage(text);
                    chatHistory.push({ role: "model", parts: [{ text: text }] }); // Model response is saved as 'model'
                } else {
                    renderMessage("The simulation hit a wall. All characters are napping. Click 'Start Chat' to try waking them.");
                    window.stopChat(); // Stop the interval on failure
                    console.error("API response missing text content:", result);
                }

            } catch (error) {
                console.error("Gemini API error:", error);
                
                let errorMessage = `Error: The conversation stalled due to a network error. (${error.message})`;
                if (error.message.includes("403")) {
                    errorMessage = "Error: The conversation stalled due to a **Forbidden (403)** error. The provided API Key may be invalid or restricted.";
                }

                renderMessage(errorMessage);
                window.stopChat(); // Stop the interval on error

            } finally {
                isSending = false;
                startButton.disabled = false;
                loadingSpinner.classList.add('hidden');
                chatWindow.scrollTop = chatWindow.scrollHeight; 
            }
        };
        
        // --- Initialization on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeTheme();
            updateStatusDisplay();
        });

    </script>
</body>
</html>
