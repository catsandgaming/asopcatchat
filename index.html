<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Cafe Autonomous Chat Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        // Custom colors based on the Cafe Cat theme
                        'cat-purple': '#8B5CF6',
                        'cat-pink': '#EC4899',
                        'cat-owner': '#34D399', // Emerald for the Owner
                        'cat-background': '#f7f7f7',
                        'cat-text': '#1f2937',
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--tw-colors-cat-background);
            min-height: 100vh;
        }
        .chat-container-main {
            height: calc(100vh - 150px); /* Adjust height for main content area */
            overflow-y: auto;
            max-width: 800px;
            margin: 0 auto;
        }
        .chat-bubble {
            border-radius: 1rem;
            padding: 0.75rem 1.25rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        /* Custom formatting for cat/owner names in dialogue */
        .cat-name {
            font-weight: 800; /* Extra bold */
            color: var(--tw-colors-cat-purple);
        }
        .owner-name {
            font-weight: 800;
            color: var(--tw-colors-cat-owner); /* Green for Owner */
        }
        .input-area {
            position: sticky;
            bottom: 0;
            background-color: white;
            padding: 1rem;
            border-top: 1px solid #e5e7eb;
            box-shadow: 0 -4px 6px -1-2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Header -->
    <header class="bg-cat-purple shadow-xl p-4 md:p-6 sticky top-0 z-10">
        <h1 class="text-3xl font-extrabold text-white text-center flex items-center justify-center">
            <span class="inline-block mr-2 text-4xl">üêà</span> A Slice Of Purrfection Cat Chat!
        </h1>
        <p class="text-sm text-cat-cream text-center mt-1">Enter a topic, and click 'Next Turn' to watch the conversation unfold!</p>
        <p id="status-display" class="text-xs text-cat-cream text-center mt-1 font-mono">Loading...</p>
    </header>

    <!-- Main Chat Window -->
    <main class="flex-grow p-4 pb-0 md:p-6 md:pb-0 chat-container-main">
        <div id="chat-window" class="space-y-4">
            <!-- Messages will be injected here -->
            <div id="initial-message" class="flex justify-center my-8">
                <div class="text-center chat-bubble bg-white border border-cat-purple/30 max-w-sm">
                    <p class="font-semibold text-gray-700 mb-2">Simulation Ready</p>
                    <p class="text-sm text-gray-500">Waiting for you to start the discussion.</p>
                </div>
            </div>
            <div id="loading-spinner" class="hidden flex justify-center py-8">
                <svg class="animate-spin h-8 w-8 text-cat-purple" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>
        </div>
    </main>

    <!-- Input/Control Area -->
    <div class="input-area">
        <div class="max-w-4xl mx-auto flex flex-col space-y-3">
            <input 
                type="text" 
                id="initial-prompt" 
                placeholder="Enter the initial scene/topic here (e.g., A customer just ordered a tuna sandwich)."
                value="The cafe just replaced the old, worn-out scratching post with a new, very modern, pastel-pink cat tower."
                class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cat-purple text-cat-text"
                onkeydown="if(event.key === 'Enter' && !isSending) document.getElementById('start-button').click()">
            
            <button id="start-button" onclick="startChat()" disabled
                    class="w-full bg-cat-purple hover:bg-cat-pink text-white font-semibold py-3 px-5 rounded-lg transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed text-lg">
                Start Chat
            </button>
        </div>
    </div>

    <!-- Firebase & OpenAI API Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Environment Globals ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- State Variables ---
        let db = null;
        let auth = null;
        let cats = [];
        let characters = []; // cats + owner
        let chatHistory = []; // Stores history in a modified format: { role: "user"|"model", text: "..." }
        let isReady = false;
        let isSending = false;
        let chatStarted = false;
        let authReady = false; 
        let configMissing = false; 

        // Character List (The Owner is defined here)
        const OWNER_PROFILE = {
            name: "Owner",
            breed: "Human",
            personality: "Caring, busy, slightly exasperated, focused on cafe operations and keeping the cats happy (and off the tables).",
            likes: ["Happy cats", "Coffee", "Quiet afternoons"],
            dislikes: ["Vet visits", "Knocked-over food displays"]
        };
        
        // --- DOM Elements ---
        const chatWindow = document.getElementById('chat-window');
        const initialPromptInput = document.getElementById('initial-prompt');
        const startButton = document.getElementById('start-button');
        const statusDisplay = document.getElementById('status-display');
        const loadingSpinner = document.getElementById('loading-spinner');
        const initialMessage = document.getElementById('initial-message');
        
        // OpenAI API Endpoint (using the standard V1 chat completions)
        const OPENAI_API_URL = `https://api.openai.com/v1/chat/completions`;

        // --- Utility Functions ---

        /**
         * Builds a detailed system instruction for the autonomous chat simulation.
         * This output is used as the 'system' message content for the OpenAI API.
         */
        function buildSystemInstruction(topic, history) {
            let instruction = "You are the autonomous script generator for a Cat Cafe Simulation. The characters are 10 cats and their Owner. ";
            instruction += "Your task is to generate the **next turn of the conversation** among 2 to 4 of these characters based on the topic and the current dialogue history. ";
            instruction += "The conversation should be dynamic, realistic, and reflect each character's established personality. The cat characters are: Ronnie, Jigsaw, Bear, Jet, Shadow, Thor, Marble, Banjo, Button, and Dash.\n\n";
            instruction += "--- RULES ---\n";
            instruction += "1. The current topic is: " + topic + "\n";
            instruction += "2. Format the entire response as a single block of dialogue using the format 'CharacterName: [Dialogue]'. Use newline characters for multiple speakers in one turn.\n";
            instruction += "3. The simulation continues until the conversation naturally concludes or hits an amusing stopping point.\n";
            instruction += "4. Do NOT include any introductory or concluding text (e.g., 'Next turn...', 'The conversation continues...'). Just output the raw dialogue.\n";
            instruction += "--- CHARACTER PROFILES ---\n";

            characters.forEach(char => {
                const likes = char.likes.join(", ");
                const dislikes = char.dislikes.length > 0 ? ` (Dislikes: ${char.dislikes.join(", ")})` : '';
                instruction += `- ${char.name} (${char.breed}): ${char.personality}. Loves: ${likes}.${dislikes}\n`;
            });
            
            if (history.length === 0) { // First turn is based on initial prompt (not in history yet)
                instruction += "\nBegin the simulation by having the characters immediately reacting to the initial topic/scene.";
            } else {
                instruction += "\nGenerate the next turn of dialogue by having the characters respond to the previous turn and move the discussion forward.";
            }

            return instruction;
        }

        /**
         * Renders a message bubble in the chat window.
         */
        function renderMessage(text) {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = 'flex justify-start w-full';
            
            const messageBubble = document.createElement('div');
            messageBubble.className = 'max-w-4xl chat-bubble mt-2 bg-white text-cat-text border border-gray-200 shadow-md whitespace-pre-wrap';
            messageBubble.innerHTML = formatDialogue(text);

            messageWrapper.appendChild(messageBubble);
            chatWindow.appendChild(messageWrapper);
            chatWindow.scrollTop = chatWindow.scrollHeight; 
        }

        /**
         * Formats the cat dialogue by highlighting names.
         */
        function formatDialogue(text) {
             // Regex to find 'CharacterName: ' at the start of a line or after a newline
            const charNames = characters.map(c => c.name).join('|');
            const dialogueRegex = new RegExp(`(^|\\n)(${charNames}): (.*)`, 'g');
            
            return text.replace(dialogueRegex, (match, p1, name, dialogue) => {
                const nameClass = name === 'Owner' ? 'owner-name' : 'cat-name';
                return `${p1}<span class="${nameClass}">${name}:</span> ${dialogue}`;
            });
        }
        
        /**
         * Makes a robust API call with exponential backoff.
         */
        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) { 
                        return response;
                    }
                    console.warn(`Rate limit hit (429). Retrying in ${2 ** i} seconds...`);
                } catch (error) {
                    console.error("Fetch error during attempt", i + 1, error);
                }
                await new Promise(resolve => setTimeout(resolve, (2 ** i) * 1000));
            }
            throw new Error("API call failed after multiple retries.");
        }


        // --- Firebase Initialization and Data Fetching (Unchanged) ---

        function initializeFirebase() {
            let configToUse = firebaseConfig;
            configMissing = Object.keys(firebaseConfig).length === 0;

            if (configMissing) {
                // Use a dummy config to prevent initializeApp from crashing 
                configToUse = { 
                    apiKey: "DUMMY", 
                    authDomain: "DUMMY.firebaseapp.com", 
                    projectId: "DUMMY", 
                    storageBucket: "DUMMY.appspot.com", 
                    messagingSenderId: "DUMMY", 
                    appId: "DUMMY" 
                };
                statusDisplay.textContent = "‚ö†Ô∏è WARNING: Config Missing. Data cannot be loaded. Run in Canvas editor.";
                console.warn("Using dummy Firebase config. Database functionality is disabled.");
            } else {
                statusDisplay.textContent = "Initializing...";
            }

            try {
                setLogLevel('debug');
                
                const app = initializeApp(configToUse);
                db = getFirestore(app);
                auth = getAuth(app);
                
                if (configMissing) {
                    loadPlaceholderCats();
                    startButton.disabled = false;
                    return;
                }

                const authPromise = initialAuthToken 
                    ? signInWithCustomToken(auth, initialAuthToken)
                    : signInAnonymously(auth);

                authPromise.catch(e => {
                    console.error("Authentication sign-in failed:", e.message);
                    statusDisplay.textContent = "Error: Failed to sign in. Check console for details.";
                });
                
                const unsubscribe = onAuthStateChanged(auth, (user) => {
                    if (user && !authReady) {
                        authReady = true;
                        console.log("Authentication successful. UID:", user.uid);
                        fetchCats();
                        unsubscribe();
                    }
                });

            } catch (error) {
                console.error("Firebase initialization error:", error);
                statusDisplay.textContent = `Error initializing: ${error.message}`;
            }
        }
        
        // Fallback cat data for when config is missing
        function loadPlaceholderCats() {
            cats = [
                { name: "Ronnie", breed: "Siamese", personality: "Vocal and demanding, often complaining about the service.", likes: ["Attention", "Warm spots"], dislikes: ["Loud noises"] },
                { name: "Jigsaw", breed: "Tabby", personality: "Adept at puzzles, often found staring intently at objects.", likes: ["Feather toys", "Quiet observation"], dislikes: ["Being rushed"] },
                { name: "Bear", breed: "Maine Coon", personality: "Large and gentle, but a clumsy bully who pushes smaller cats.", likes: ["Cuddles", "Big naps"], dislikes: ["Small spaces"] },
                { name: "Jet", breed: "Black Cat", personality: "Sleek and mysterious, spends most of its time watching birds.", likes: ["High places", "Shadows"], dislikes: ["Bright lights"] },
                { name: "Shadow", breed: "Sphynx", personality: "Naked and perpetually cold, constantly seeking warmth from customers or appliances.", likes: ["Sweaters", "Heat vents"], dislikes: ["Cold air"] },
                { name: "Thor", breed: "Ragdoll", personality: "Sweet and floppy, but has a dramatic flair for 'fainting' when picked up.", likes: ["Belly rubs", "Soft blankets"], dislikes: ["Being held tightly"] },
                { name: "Marble", breed: "Calico", personality: "A true diva, highly photogenic, and knows it. Demands the best sunbeams.", likes: ["Cameras", "Sunbeams"], dislikes: ["Being ignored"] },
                { name: "Banjo", breed: "Munchkin", personality: "Short-legged and perpetually playful, always tripping over its own feet.", likes: ["Laser pointers", "Chasing dust"], dislikes: ["Stairs"] },
                { name: "Button", breed: "Scottish Fold", personality: "Sweetest cat in the cafe, but prone to anxiety. Hides behind the register.", likes: ["Owner", "Inside boxes"], dislikes: ["New people"] },
                { name: "Dash", breed: "Bengal", personality: "High-energy and athletic, constantly running laps around the tables.", likes: ["Running", "Climbing"], dislikes: ["Sitting still"] }
            ];
            characters = [...cats, OWNER_PROFILE];
            isReady = true;
            startButton.disabled = false;
            statusDisplay.textContent = "‚ö†Ô∏è WARNING: Using placeholder data. Ready to start!";
        }


        function fetchCats() {
            if (configMissing) return;
            if (!db) {
                console.error("Firestore database instance is not available.");
                statusDisplay.textContent = "Database not initialized.";
                return;
            }
            
            // Public collection path: /artifacts/{appId}/public/data/cats
            const catCollectionPath = `artifacts/${appId}/public/data/cats`;
            const q = query(collection(db, catCollectionPath));

            onSnapshot(q, (querySnapshot) => {
                cats = [];
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.name) {
                        cats.push(data);
                    }
                });

                characters = [...cats, OWNER_PROFILE];

                if (cats.length === 10) {
                    isReady = true;
                    startButton.disabled = false;
                    statusDisplay.textContent = `10 Cat Profiles + Owner Loaded. Ready to start!`;
                    console.log("All 11 character profiles loaded successfully.");
                } else {
                    statusDisplay.textContent = `Loading cat profiles (${cats.length}/10)... If stuck, ensure cat data is imported!`;
                }
            }, (error) => {
                console.error("Error fetching cat data:", error);
                statusDisplay.textContent = "Error loading cat data: Missing or insufficient permissions. Run the data importer!";
            });
        }
        
        // --- Simulation Logic ---

        window.startChat = async function() {
            if (!isReady || isSending) return;

            const topic = initialPromptInput.value.trim();
            if (!topic) return;

            initialMessage.classList.add('hidden');
            
            if (!chatStarted) {
                // Initialize for the first turn - note the simplified history object
                chatHistory = [];
                chatHistory.push({ role: "user", text: "Initial Scene/Topic: " + topic });
                chatStarted = true;
                initialPromptInput.disabled = true;

                // Change button text and function
                startButton.textContent = "Next Turn";
                startButton.onclick = window.generateNextTurn;

                renderMessage(`**SIMULATION START** - Topic: ${topic}`);
            }

            // Immediately generate the first turn
            window.generateNextTurn();
        }

        window.generateNextTurn = async function() {
            if (!isReady || isSending) return;

            // Get the topic from the disabled input field
            const topic = initialPromptInput.value.trim();
            
            isSending = true;
            startButton.disabled = true;
            loadingSpinner.classList.remove('hidden');

            const systemPrompt = buildSystemInstruction(topic, chatHistory);

            // Convert local chatHistory to OpenAI messages format
            const openaiMessages = [
                // 1. System Prompt (The Persona and Rules)
                { role: "system", content: systemPrompt },
                // 2. Conversation History
                ...chatHistory.map(h => ({
                    role: h.role === "model" ? "assistant" : "user",
                    content: h.text
                }))
            ];
            
            const payload = {
                model: "gpt-3.5-turbo",
                messages: openaiMessages,
                temperature: 0.8, // Make the dialogue slightly creative
            };
            
            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            // Call API and Handle Response
            try {
                const response = await fetchWithRetry(OPENAI_API_URL, options);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API returned status ${response.status}. Response: ${errorText.substring(0, 100)}...`);
                }

                const result = await response.json();
                
                // Extract text from OpenAI response structure
                const text = result.choices?.[0]?.message?.content;

                if (text) {
                    // Display model message and update history
                    renderMessage(text);
                    // Store the response in the local history using the 'model' role
                    chatHistory.push({ role: "model", text: text });
                } else {
                    renderMessage("The simulation hit a wall. All characters are napping. Click 'Next Turn' to try waking them.");
                    console.error("OpenAI API response missing text content or choices:", result);
                }

            } catch (error) {
                console.error("OpenAI API error:", error);
                renderMessage(`Error: The network connection failed or the characters are too confused to talk. (${error.message})`);

            } finally {
                // Cleanup
                isSending = false;
                startButton.disabled = false;
                loadingSpinner.classList.add('hidden');
                chatWindow.scrollTop = chatWindow.scrollHeight; 
            }
        };


        // --- Initialization on Load ---
        window.onload = initializeFirebase;
    </script>
</body>
</html>
